// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: merkle.sql

package queries

import (
	"context"
	"database/sql"
)

const insertProof = `-- name: InsertProof :exec
insert into merkle_proofs (root, unhashed_leaf, address, proof)
values ($1, $2, $3, $4)
on conflict (root, unhashed_leaf) do nothing
`

type InsertProofParams struct {
	Root         []byte   `json:"root"`
	UnhashedLeaf []byte   `json:"unhashedLeaf"`
	Address      []byte   `json:"address"`
	Proof        [][]byte `json:"proof"`
}

func (q *Queries) InsertProof(ctx context.Context, arg InsertProofParams) error {
	_, err := q.db.Exec(ctx, insertProof,
		arg.Root,
		arg.UnhashedLeaf,
		arg.Address,
		arg.Proof,
	)
	return err
}

const insertTree = `-- name: InsertTree :exec
insert into merkle_trees (root, unhashed_leaves, ltd, packed)
values ($1, $2, $3, $4)
on conflict (root) do nothing
`

type InsertTreeParams struct {
	Root           []byte       `json:"root"`
	UnhashedLeaves [][]byte     `json:"unhashedLeaves"`
	Ltd            []string     `json:"ltd"`
	Packed         sql.NullBool `json:"packed"`
}

func (q *Queries) InsertTree(ctx context.Context, arg InsertTreeParams) error {
	_, err := q.db.Exec(ctx, insertTree,
		arg.Root,
		arg.UnhashedLeaves,
		arg.Ltd,
		arg.Packed,
	)
	return err
}

const selectLeaves = `-- name: SelectLeaves :one
select unhashed_leaves
from merkle_trees
where root = $1
`

func (q *Queries) SelectLeaves(ctx context.Context, root []byte) ([][]byte, error) {
	row := q.db.QueryRow(ctx, selectLeaves, root)
	var unhashed_leaves [][]byte
	err := row.Scan(&unhashed_leaves)
	return unhashed_leaves, err
}

const selectProofByAddress = `-- name: SelectProofByAddress :many
select proof
from merkle_proofs
where root = $1
and address = $2
`

type SelectProofByAddressParams struct {
	Root    []byte `json:"root"`
	Address []byte `json:"address"`
}

func (q *Queries) SelectProofByAddress(ctx context.Context, arg SelectProofByAddressParams) ([][][]byte, error) {
	rows, err := q.db.Query(ctx, selectProofByAddress, arg.Root, arg.Address)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items [][][]byte
	for rows.Next() {
		var proof [][]byte
		if err := rows.Scan(&proof); err != nil {
			return nil, err
		}
		items = append(items, proof)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectProofByUnhashedLeaf = `-- name: SelectProofByUnhashedLeaf :one
select proof
from merkle_proofs
where root = $1
and unhashed_leaf = $2
`

type SelectProofByUnhashedLeafParams struct {
	Root         []byte `json:"root"`
	UnhashedLeaf []byte `json:"unhashedLeaf"`
}

func (q *Queries) SelectProofByUnhashedLeaf(ctx context.Context, arg SelectProofByUnhashedLeafParams) ([][]byte, error) {
	row := q.db.QueryRow(ctx, selectProofByUnhashedLeaf, arg.Root, arg.UnhashedLeaf)
	var proof [][]byte
	err := row.Scan(&proof)
	return proof, err
}
