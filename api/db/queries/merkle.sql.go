// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: merkle.sql

package queries

import (
	"context"
)

const getAddressesForMerkleTree = `-- name: GetAddressesForMerkleTree :one
select addresses from merkle_trees where root = $1
`

func (q *Queries) GetAddressesForMerkleTree(ctx context.Context, root []byte) ([][]byte, error) {
	row := q.db.QueryRow(ctx, getAddressesForMerkleTree, root)
	var addresses [][]byte
	err := row.Scan(&addresses)
	return addresses, err
}

const getMerkleProof = `-- name: GetMerkleProof :one
select proof from merkle_proofs where root = $1 and address = $2
`

type GetMerkleProofParams struct {
	Root    []byte `json:"root"`
	Address []byte `json:"address"`
}

func (q *Queries) GetMerkleProof(ctx context.Context, arg GetMerkleProofParams) ([][]byte, error) {
	row := q.db.QueryRow(ctx, getMerkleProof, arg.Root, arg.Address)
	var proof [][]byte
	err := row.Scan(&proof)
	return proof, err
}

const insertMerkleProof = `-- name: InsertMerkleProof :exec
insert into merkle_proofs (root, address, proof)
values ($1, $2, $3)
on conflict (root, address) do nothing
`

type InsertMerkleProofParams struct {
	Root    []byte   `json:"root"`
	Address []byte   `json:"address"`
	Proof   [][]byte `json:"proof"`
}

func (q *Queries) InsertMerkleProof(ctx context.Context, arg InsertMerkleProofParams) error {
	_, err := q.db.Exec(ctx, insertMerkleProof, arg.Root, arg.Address, arg.Proof)
	return err
}

const insertMerkleTree = `-- name: InsertMerkleTree :exec
insert into merkle_trees (root, addresses)
values ($1, $2)
on conflict (root) do nothing
`

type InsertMerkleTreeParams struct {
	Root      []byte   `json:"root"`
	Addresses [][]byte `json:"addresses"`
}

func (q *Queries) InsertMerkleTree(ctx context.Context, arg InsertMerkleTreeParams) error {
	_, err := q.db.Exec(ctx, insertMerkleTree, arg.Root, arg.Addresses)
	return err
}
