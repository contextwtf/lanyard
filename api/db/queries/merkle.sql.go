// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: merkle.sql

package queries

import (
	"context"
	"database/sql"
)

const insertProof = `-- name: InsertProof :exec
insert into merkle_proofs (root, unhashed_leaf, address, proof)
values ($1, $2, $3, $4)
on conflict (root, unhashed_leaf) do nothing
`

type InsertProofParams struct {
	Root         []byte   `json:"root"`
	UnhashedLeaf []byte   `json:"unhashedLeaf"`
	Address      []byte   `json:"address"`
	Proof        [][]byte `json:"proof"`
}

func (q *Queries) InsertProof(ctx context.Context, arg InsertProofParams) error {
	_, err := q.db.Exec(ctx, insertProof,
		arg.Root,
		arg.UnhashedLeaf,
		arg.Address,
		arg.Proof,
	)
	return err
}

const insertTree = `-- name: InsertTree :exec
insert into merkle_trees (root, unhashed_leaves, ltd, packed)
values ($1, $2, $3, $4)
on conflict (root) do nothing
`

type InsertTreeParams struct {
	Root           []byte       `json:"root"`
	UnhashedLeaves [][]byte     `json:"unhashedLeaves"`
	Ltd            []string     `json:"ltd"`
	Packed         sql.NullBool `json:"packed"`
}

func (q *Queries) InsertTree(ctx context.Context, arg InsertTreeParams) error {
	_, err := q.db.Exec(ctx, insertTree,
		arg.Root,
		arg.UnhashedLeaves,
		arg.Ltd,
		arg.Packed,
	)
	return err
}

const selectProofByAddress = `-- name: SelectProofByAddress :many
select proof, unhashed_leaf
from merkle_proofs
where root = $1
and address = $2
`

type SelectProofByAddressParams struct {
	Root    []byte `json:"root"`
	Address []byte `json:"address"`
}

type SelectProofByAddressRow struct {
	Proof        [][]byte `json:"proof"`
	UnhashedLeaf []byte   `json:"unhashedLeaf"`
}

func (q *Queries) SelectProofByAddress(ctx context.Context, arg SelectProofByAddressParams) ([]SelectProofByAddressRow, error) {
	rows, err := q.db.Query(ctx, selectProofByAddress, arg.Root, arg.Address)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectProofByAddressRow
	for rows.Next() {
		var i SelectProofByAddressRow
		if err := rows.Scan(&i.Proof, &i.UnhashedLeaf); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectProofByUnhashedLeaf = `-- name: SelectProofByUnhashedLeaf :one
select proof
from merkle_proofs
where root = $1
and unhashed_leaf = $2
`

type SelectProofByUnhashedLeafParams struct {
	Root         []byte `json:"root"`
	UnhashedLeaf []byte `json:"unhashedLeaf"`
}

func (q *Queries) SelectProofByUnhashedLeaf(ctx context.Context, arg SelectProofByUnhashedLeafParams) ([][]byte, error) {
	row := q.db.QueryRow(ctx, selectProofByUnhashedLeaf, arg.Root, arg.UnhashedLeaf)
	var proof [][]byte
	err := row.Scan(&proof)
	return proof, err
}

const selectTree = `-- name: SelectTree :one
select unhashed_leaves, ltd, packed
from merkle_trees
where root = $1
`

type SelectTreeRow struct {
	UnhashedLeaves [][]byte     `json:"unhashedLeaves"`
	Ltd            []string     `json:"ltd"`
	Packed         sql.NullBool `json:"packed"`
}

func (q *Queries) SelectTree(ctx context.Context, root []byte) (SelectTreeRow, error) {
	row := q.db.QueryRow(ctx, selectTree, root)
	var i SelectTreeRow
	err := row.Scan(&i.UnhashedLeaves, &i.Ltd, &i.Packed)
	return i, err
}

const selectTreeExists = `-- name: SelectTreeExists :one
select exists(select 1 from merkle_trees where root = $1)
`

func (q *Queries) SelectTreeExists(ctx context.Context, root []byte) (bool, error) {
	row := q.db.QueryRow(ctx, selectTreeExists, root)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
