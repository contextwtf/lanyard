// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: batch.go
package queries

import (
	"context"

	"github.com/jackc/pgx/v4"
)

const insertProof = `-- name: InsertProof :batchexec
insert into merkle_proofs (root, unhashed_leaf, address, proof)
values ($1, $2, $3, $4)
on conflict (root, unhashed_leaf) do nothing
`

type InsertProofBatchResults struct {
	br  pgx.BatchResults
	ind int
}

type InsertProofParams struct {
	Root         []byte   `json:"root"`
	UnhashedLeaf []byte   `json:"unhashedLeaf"`
	Address      []byte   `json:"address"`
	Proof        [][]byte `json:"proof"`
}

func (q *Queries) InsertProof(ctx context.Context, arg []InsertProofParams) *InsertProofBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Root,
			a.UnhashedLeaf,
			a.Address,
			a.Proof,
		}
		batch.Queue(insertProof, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &InsertProofBatchResults{br, 0}
}

func (b *InsertProofBatchResults) Exec(f func(int, error)) {
	for {
		_, err := b.br.Exec()
		if err != nil && (err.Error() == "no result" || err.Error() == "batch already closed") {
			break
		}
		if f != nil {
			f(b.ind, err)
		}
		b.ind++
	}
}

func (b *InsertProofBatchResults) Close() error {
	return b.br.Close()
}
